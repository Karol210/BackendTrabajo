---
description: Gu√≠a para crear servicios Spring con arquitectura en capas y principios SOLID
globs: ["**/service/**/*.java"]
alwaysApply: true
---

# üèóÔ∏è Creaci√≥n de Servicios - Arquitectura en Capas

## üìã TL;DR

- ‚úÖ **CR√çTICO**: Verificar DTOs/modelos/servicios existentes ANTES de crear - reutilizar sin modificar tipos/nombres
- ‚úÖ **OBLIGATORIO**: Solicitar URL, CURL y responses (√©xito + error) ANTES de crear servicio
- ‚úÖ **OBLIGATORIO**: Usar MapStruct para mapeo entre DTOs y entidades (NO mapeo manual ni ModelMapper)
- ‚úÖ Arquitectura: Controller ‚Üí Service Principal ‚Üí External Service ‚Üí Feign Client ‚Ä¢ Inyecci√≥n por interfaz
- ‚úÖ Organizaci√≥n: Simple (1 op) / Organizada (‚â•2 ops) / Modular (m√≥dulo completo)
- ‚úÖ Servicios External en `service/{dominio}/external/` ‚Ä¢ Para ‚â•2 capacidades, ver regla 09

## üö® Reglas Principales

1. **Verificaci√≥n obligatoria**: Antes de crear, buscar DTOs/modelos/servicios/endpoints existentes en `dto/`, `documents/`, `models/`, `service/`. Reutilizar sin modificar tipos/nombres de campos (solo agregar nuevos). Preguntar al usuario sobre controller (nuevo o reutilizar).
2. **Validaci√≥n previa**: Solicitar URL, CURL y responses JSON (√©xito + error) ANTES de crear cualquier servicio. No inventar estructura de DTOs.
3. **Mapeo con MapStruct**: SIEMPRE usar MapStruct para convertir entre DTOs y entidades. Crear interface `@Mapper` con `componentModel = "spring"` en paquete `mapper/{dominio}/`. NO usar mapeo manual ni otras librer√≠as (ModelMapper, Dozer).
4. **Arquitectura en capas**: Controller ‚Üí Service (Interface) ‚Üí Service Impl ‚Üí External Service ‚Üí Feign Client. Servicios External SIEMPRE en paquete `service/{dominio}/external/`.
5. **Inyecci√≥n de dependencias**: SIEMPRE por interfaz usando `@RequiredArgsConstructor` (NUNCA `@Autowired` ni implementaciones concretas).
6. **Organizaci√≥n por complejidad**: Simple (1 op) en `service/{dominio}/`, Organizada (‚â•2 ops) con subcarpetas `service/{dominio}/{operacion}/`, Modular (m√≥dulo completo) con paquetes en todas las capas.

## üìä Referencia R√°pida

### Tipos de Servicios

| Tipo | Sufijo | Responsabilidad | Ubicaci√≥n | Dependencias | Exposici√≥n |
|------|--------|----------------|-----------|--------------|------------|
| Principal | `ServiceImpl` | Coordinar flujo completo, validaciones de negocio | `service/{dominio}/` | Servicios External | ‚úÖ P√∫blica |
| External | `External*ServiceImpl` | Comunicaci√≥n con APIs externas | `service/{dominio}/external/` | Feign Clients | ‚ùå Interna |
| Especializado | `*ServiceImpl` | Tarea espec√≠fica del dominio | `service/{dominio}/` | Feign Clients, otros servicios | ‚úÖ P√∫blica |
| Processor | `*Processor` | Transformar/procesar datos | `service/{dominio}/` | Ninguna o DTOs | ‚ùå Interna |
| Organization | `*OrganizationService` | Ordenar/agrupar datos (uso interno) | `service/{dominio}/organization/` | Ninguna o DTOs | ‚ùå Interna |
| Retriever | `*RepositoryImpl` | Acceso a bases de datos | `service/{dominio}/` | JPA, MongoDB Repositories | ‚ùå Interna |

### Decisi√≥n de Controller y Exposici√≥n de APIs

**üî¥ CR√çTICO: SIEMPRE preguntar al usuario ANTES de crear o modificar controllers**

#### Pregunta 1: ¬øEl servicio debe ser expuesto p√∫blicamente?

| Tipo de Servicio | ¬øExponer API? | Acci√≥n |
|------------------|:-------------:|--------|
| Processor / Organization / Retriever | ‚ùå NO | Uso interno solamente - NO crear endpoint |
| Principal / Especializado | ‚ö†Ô∏è Preguntar | "¬øDeseas exponer esta funcionalidad como API REST?" |

**Servicios que NO deben exponerse:**
- ‚úÖ Servicios de procesamiento/transformaci√≥n de datos (`*Processor`, `*OrganizationService`)
- ‚úÖ Servicios de acceso a datos (`*Repository`, `*Retriever`)
- ‚úÖ Servicios auxiliares que son usados por otros servicios internamente

**Servicios que pueden exponerse (previa aprobaci√≥n):**
- ‚ö†Ô∏è Servicios principales que coordinan flujos de negocio
- ‚ö†Ô∏è Servicios especializados con funcionalidad espec√≠fica del dominio

#### Pregunta 2: Si el usuario aprueba exponer, ¬ønuevo controller o reutilizar?

| Pregunta | Opci√≥n A | Opci√≥n B |
|----------|----------|----------|
| "¬øDeseas crear un **nuevo controller** o **reutilizar uno existente**?" | Crear nuevo controller separado | Agregar endpoint a controller existente |

**Criterios para crear nuevo controller:**
- ‚úÖ Funcionalidad completamente independiente del dominio existente
- ‚úÖ Requiere ruta base diferente (ej: `/api/v1/declaracion-asegurabilidad` vs `/api/v1/oferta`)
- ‚úÖ Endpoints relacionados a un m√≥dulo espec√≠fico
- ‚úÖ Documentaci√≥n Swagger diferenciada

**Criterios para reutilizar controller existente:**
- ‚úÖ Endpoints relacionados al mismo dominio
- ‚úÖ Comparten ruta base com√∫n
- ‚úÖ Operaciones sobre la misma entidad principal

### Estructura de Carpetas

| Caso | Estructura | Cu√°ndo usar | Ejemplo |
|------|-----------|-------------|---------|
| **Simple** | `service/{dominio}/` | Una funcionalidad, DTOs compartidos | `service/shorturl/` |
| **Organizada** | `service/{dominio}/{operacion}/` | ‚â•2 ops HTTP diferentes | `service/transaction/detail/` + `step/` |
| **Modular** ‚≠ê | `service/{modulo}/` + paquetes en todas capas | M√≥dulo completo independiente | `service/processconfig/` + `controller/processconfig/` + `exception/processconfig/` |
| **Interna** | `service/{dominio}/organization/` | Servicios de procesamiento/organizaci√≥n (NO expuestos) | `service/insurability/organization/` |

**Criterios para Estructura Modular:**

| Criterio | Simple | Organizada | Modular |
|----------|:------:|:----------:|:-------:|
| 1 operaci√≥n | ‚úÖ | ‚ùå | ‚ùå |
| ‚â•2 ops misma entidad | ‚ùå | ‚úÖ | ‚ùå |
| M√≥dulo completo (controller + service + dto + exception) | ‚ùå | ‚ùå | ‚úÖ |
| Con README.md propio | ‚ùå | ‚ùå | ‚úÖ |

### Validaci√≥n de DTOs/Modelos/Servicios/Endpoints Existentes

**‚ö†Ô∏è CR√çTICO**: Verificar existentes ANTES de crear nuevos

| Tipo | D√≥nde buscar | Ejemplo |
|------|-------------|---------|
| DTOs | `dto/{dominio}/` | `dto/processconfig/` |
| Documentos | `documents/` | `documents/allies/WorkFlowAlly` |
| Modelos | `models/` | `models/Response` |
| Servicios | `service/` | `TransactionService` para tracking |
| Endpoints | `service/**/external/` | Feign Clients con `@PathVariable` |

**Regla de Reutilizaci√≥n:**
- ‚úÖ Existe ‚Üí Reutilizar y agregar SOLO campos faltantes
- ‚úÖ Endpoint con path variable ‚Üí Pasar par√°metro din√°mico
- ‚ùå Solo crear nuevo si NO existe alternativa

**üö´ PROHIBIDO al reutilizar DTOs/Modelos:**
- ‚ùå **NO cambiar tipos de datos** de campos existentes (ej: `boolean` ‚Üí `Boolean`)
- ‚ùå **NO cambiar nombres** de campos existentes
- ‚ùå **NO cambiar anotaciones** existentes (`@JsonProperty`, `@Field`)
- ‚ùå **NO modificar JavaDoc** de campos existentes
- ‚úÖ **SOLO agregar** campos nuevos al final

**Beneficios:** ~100-200 l√≠neas menos, sin mapeos, mantenimiento √∫nico

### Arquitectura con Servicios External

**Patr√≥n completo para consumir APIs externas:**

```
controller/
‚îî‚îÄ‚îÄ {Dominio}Controller.java
    ‚Üì inyecta
service/{dominio}/
‚îú‚îÄ‚îÄ {Dominio}Service.java (Interface)
‚îú‚îÄ‚îÄ {Dominio}ServiceImpl.java (Principal)
‚îÇ   ‚Üì inyecta
‚îî‚îÄ‚îÄ external/
    ‚îú‚îÄ‚îÄ External{Servicio}Client.java (Feign)
    ‚îú‚îÄ‚îÄ External{Servicio}Service.java (Interface)
    ‚îî‚îÄ‚îÄ External{Servicio}ServiceImpl.java (Implementaci√≥n)
```

**Flujo de responsabilidades:**
1. **Controller**: Recibe request, valida entrada, delega a servicio principal (‚ö†Ô∏è SOLO si el usuario aprob√≥ exponer la API)
2. **Servicio Principal**: Coordina operaciones, aplica reglas de negocio, valida respuestas
3. **Servicio External**: Maneja comunicaci√≥n con API externa, valida respuestas t√©cnicas
4. **Feign Client**: Define contrato de API externa
5. **Servicio Organization** (opcional): Procesa/organiza datos internamente - NO expuesto en controller

> **Nota**: Si hay ‚â•2 capacidades en `external/` (ej: auth + questions), organizar en subcarpetas por capacidad.  
> Ver [servicios-09-organizacion-capacidades.mdc](./servicios-09-organizacion-capacidades.mdc) para detalles.

### Mapeo con MapStruct (OBLIGATORIO)

| Aspecto | Convenci√≥n | Ejemplo |
|---|---|---|
| Ubicaci√≥n | `mapper/{dominio}/` | `mapper/user/UserMapper.java` |
| Anotaci√≥n | `@Mapper(componentModel = "spring")` | Inyecci√≥n autom√°tica |
| Nomenclatura | `{Dominio}Mapper` | `UserMapper`, `ProductMapper` |
| M√©todos | Conversi√≥n bidireccional | `toEntity()`, `toResponseDto()` |
| Inyecci√≥n | Por interfaz en servicios | `private final UserMapper userMapper;` |

**Beneficios de MapStruct:**
- ‚úÖ Mapeo compile-time (sin reflexi√≥n)
- ‚úÖ Type-safe y r√°pido
- ‚úÖ C√≥digo generado autom√°ticamente
- ‚úÖ F√°cil de testear y mantener
- ‚úÖ Manejo autom√°tico de campos con mismo nombre

## ‚úÖ Ejemplos

### Ejemplo 1: Arquitectura Completa con Servicio External

**Controller (SOLO si usuario aprueba exposici√≥n):**
```java
@RestController
@RequestMapping("/api/v1/declaracion-asegurabilidad")
@RequiredArgsConstructor
public class InsurabilityController {
    private final InsurabilityService insurabilityService;

    @PostMapping("/preguntas")
    public InsurabilityQuestionsResponseDto getInsurabilityQuestions(
            @RequestHeader("Authorization") String authorization,
            @Valid @RequestBody InsurabilityQuestionsRequestDto request) {
        return insurabilityService.getInsurabilityQuestions(request, authorization);
    }
}
```

**Servicio Principal (coordina y valida negocio):**
```java
@Slf4j
@Service
@RequiredArgsConstructor
public class InsurabilityServiceImpl implements InsurabilityService {
    private final ExternalInsurabilityQuestionsService externalInsurabilityQuestionsService;

    @Override
    public InsurabilityQuestionsResponseDto getInsurabilityQuestions(
            InsurabilityQuestionsRequestDto request, String authorization) {
        // 1. Validar entrada
        if (authorization == null || authorization.trim().isEmpty()) {
            throw new ParametersException("Token requerido", CODE_AUTH_REQUIRED);
        }
        // 2. Delegar a servicio external
        InsurabilityQuestionsResponseDto response = 
            externalInsurabilityQuestionsService.getInsurabilityQuestions(request, authorization);
        // 3. Validar respuesta de negocio
        if (!response.isSuccess()) {
            throw new ParametersException("Error: " + response.getMessage(), CODE_ERROR);
        }
        return response;
    }
}
```

**Servicio External (service/insurability/external/):**
```java
@Slf4j
@Service
@RequiredArgsConstructor
public class ExternalInsurabilityQuestionsServiceImpl 
        implements ExternalInsurabilityQuestionsService {
    private final ExternalInsurabilityQuestionsClient client;

    @Override
    public InsurabilityQuestionsResponseDto getInsurabilityQuestions(
            InsurabilityQuestionsRequestDto request, String authorization) {
        try {
            InsurabilityQuestionsResponseDto response = client.getInsurabilityQuestions(authorization, request);
            if (response == null) throw new ParametersException("Respuesta nula", CODE_NULL_RESPONSE);
            return response;
        } catch (ParametersException e) {
            throw e;
        } catch (Exception e) {
            throw new ParametersException("Error externo: " + e.getMessage(), CODE_EXTERNAL_ERROR, e);
        }
    }
}
```

**Feign Client (service/insurability/external/):**
```java
@FeignClient(name = "insurability-questions-client", url = "${domain.gestor.url}")
public interface ExternalInsurabilityQuestionsClient {
    @PostMapping("${domain.gestor.endpoints.insurability-questions}")
    InsurabilityQuestionsResponseDto getInsurabilityQuestions(
            @RequestHeader("Authorization") String authorization,
            @RequestBody InsurabilityQuestionsRequestDto request);
}
```

### Ejemplo 2: Servicio que Coordina M√∫ltiples Servicios

```java
@Slf4j
@Service
@RequiredArgsConstructor
public class ShortUrlServiceImpl implements ShortUrlService {
    private final ShortUrlParameterResolutionService parameterService;
    private final ExternalUrlShortenerService externalService;

    @Override
    public ShortUrlResponse shortenUrl(ShortUrlRequest request) {
        // 1. Resolver par√°metros ‚Üí 2. Acortar URL ‚Üí 3. Construir respuesta
        ResolvedShortUrlParametersDto params = parameterService.resolveParameters(request);
        String urlCorta = externalService.shortenUrl(request.longURL(), params.idSistemaOrigen(), params.diasVigencia());
        return new ShortUrlResponse(request.longURL(), urlCorta, params.diasVigencia());
    }
}
```


### Ejemplo 3: Reutilizaci√≥n (CR√çTICO)

| Elemento | ‚ùå Crear nuevo | ‚úÖ Reutilizar existente |
|----------|--------------|------------------------|
| **Endpoint** | Duplicar m√©todo | `parameterClient.consultChannelParameters("recortarUrl")` |
| **DTO** | Nuevo archivo | Agregar campos al DTO existente (NO modificar tipos) |
| **Servicio** | Nueva clase | `transactionService.saveTransactionStep(id, "paso", dto)` |

**Beneficios**: ~100-200 l√≠neas menos, sin mapeos, mantenimiento √∫nico

### Ejemplo 4: Servicio Organization (Uso Interno)

**Ubicaci√≥n**: `service/insurability/organization/`

```java
@Slf4j
@Service
public class InsurabilityQuestionsOrganizationServiceImpl 
        implements InsurabilityQuestionsOrganizationService {

    @Override
    public Map<Integer, List<InsurabilityQuestionDto>> groupQuestionsByParentIdAscending(
            List<InsurabilityQuestionDto> questions) {
        if (questions == null || questions.isEmpty()) return Collections.emptyMap();

        Map<Integer, List<InsurabilityQuestionDto>> grouped = questions.stream()
                .collect(Collectors.groupingBy(q -> q.getParentQuestionId() != null ? q.getParentQuestionId() : 0));
        grouped.forEach((parentId, list) -> list.sort(Comparator.comparing(q -> q.getOrder() != null ? q.getOrder() : Integer.MAX_VALUE)));
        return grouped;
    }
}
```

**Caracter√≠sticas:**
- ‚úÖ Uso INTERNO - NO exponer sin aprobaci√≥n del usuario
- ‚úÖ Sin DTOs propios (reutiliza DTOs existentes)
- ‚úÖ Sin Feign Clients
- ‚ö†Ô∏è Si usuario solicita exponer ‚Üí PREGUNTAR antes de crear endpoint

### Ejemplo 5: Mapeo con MapStruct (OBLIGATORIO)

**Mapper (mapper/user/UserMapper.java):**
```java
package com.ecommerce.davivienda.mapper.user;

import com.ecommerce.davivienda.dto.user.UserRequestDto;
import com.ecommerce.davivienda.dto.user.UserResponseDto;
import com.ecommerce.davivienda.entity.User;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

/**
 * Mapper para conversiones entre User y DTOs.
 * MapStruct genera la implementaci√≥n autom√°ticamente en tiempo de compilaci√≥n.
 */
@Mapper(componentModel = "spring")
public interface UserMapper {

    /**
     * Convierte UserRequestDto a entidad User.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    User toEntity(UserRequestDto requestDto);

    /**
     * Convierte entidad User a UserResponseDto.
     */
    UserResponseDto toResponseDto(User user);

    /**
     * Actualiza campos de User desde UserRequestDto.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    void updateEntityFromDto(UserRequestDto requestDto, @MappingTarget User user);
}
```

**Uso en Servicio:**
```java
@Slf4j
@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {
    private final UserRepository userRepository;
    private final UserMapper userMapper;  // ‚úÖ Inyecci√≥n de MapStruct mapper

    @Override
    @Transactional
    public UserResponseDto createUser(UserRequestDto request) {
        User user = userMapper.toEntity(request);  // ‚úÖ Mapeo con MapStruct
        User savedUser = userRepository.save(user);
        return userMapper.toResponseDto(savedUser);  // ‚úÖ Mapeo con MapStruct
    }

    @Override
    @Transactional
    public UserResponseDto updateUser(Long id, UserRequestDto request) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new UserException("Usuario no encontrado", CODE_USER_NOT_FOUND));
        userMapper.updateEntityFromDto(request, user);  // ‚úÖ Mapeo con MapStruct
        return userMapper.toResponseDto(userRepository.save(user));
    }
}
```

**‚ùå NO hacer mapeo manual:**
```java
// ‚ùå INCORRECTO - Mapeo manual
User user = new User();
user.setName(request.getName());
user.setEmail(request.getEmail());
user.setDocumentType(request.getDocumentType());
user.setDocumentNumber(request.getDocumentNumber());
// ... 20 l√≠neas m√°s de setters
```

**‚úÖ Beneficios de MapStruct:**
- üéØ 5-10 l√≠neas vs 20-30 l√≠neas de mapeo manual
- üéØ Seguridad de tipos en tiempo de compilaci√≥n
- üéØ Sin errores de reflexi√≥n en runtime
- üéØ F√°cil de mantener cuando se agregan campos

## üö´ Restricciones

1. **NO** crear DTOs/modelos/servicios sin verificar existentes en `dto/`, `documents/`, `models/`, `service/`
2. **NO** modificar tipos de datos ni nombres de campos existentes al reutilizar (solo agregar nuevos)
3. **NO** crear servicios sin URL, CURL y responses JSON reales (no inventar estructura)
4. **NO** usar mapeo manual entre DTOs y entidades (usar MapStruct obligatoriamente)
5. **NO** usar otras librer√≠as de mapeo (ModelMapper, Dozer, BeanUtils) en lugar de MapStruct
6. **NO** crear mappers sin `@Mapper(componentModel = "spring")`
7. **NO** colocar mappers fuera del paquete `mapper/{dominio}/`
8. **NO** inyectar implementaciones (`*ServiceImpl`) ni usar `@Autowired` (usar interfaces + `@RequiredArgsConstructor`)
9. **NO** llamar Feign Clients directamente desde servicios principales (usar servicio External en `external/`)
10. **NO** crear o modificar controllers sin preguntar PRIMERO al usuario si desea exponer la API
11. **NO** exponer servicios de procesamiento/organizaci√≥n sin aprobaci√≥n expl√≠cita del usuario
12. **NO** crear servicios sin interfaz correspondiente
13. **NO** hardcodear mensajes de error (usar constantes en `Constants.java`)
14. **NO** usar nomenclatura inconsistente (`premiumcalculation` vs `premiumCalculation` - usar camelCase)
15. **NO** crear servicios external fuera del paquete `service/{dominio}/external/`
16. **NO** crear servicios de organizaci√≥n/procesamiento fuera del paquete `service/{dominio}/organization/`

## ‚úÖ Validaci√≥n Autom√°tica

Cursor debe detectar:

- ‚ùå Creaci√≥n sin verificar DTOs/modelos/servicios existentes
- ‚ùå Modificaci√≥n de tipos de datos (`boolean` ‚Üí `Boolean`) o nombres de campos existentes
- ‚ùå Creaci√≥n de servicios sin URL, CURL y responses JSON
- ‚ùå Mapeo manual entre DTOs y entidades (uso de `new Entity()` con m√∫ltiples setters)
- ‚ùå Uso de `ModelMapper`, `Dozer`, `BeanUtils.copyProperties()` en lugar de MapStruct
- ‚ùå Mappers sin anotaci√≥n `@Mapper(componentModel = "spring")`
- ‚ùå Mappers ubicados fuera del paquete `mapper/{dominio}/`
- ‚ùå Servicios sin inyecci√≥n de mapper cuando hay conversiones DTO ‚Üî Entidad
- ‚ùå Creaci√≥n o modificaci√≥n de controller sin preguntar PRIMERO al usuario
- ‚ùå Exposici√≥n autom√°tica de servicios de procesamiento/organizaci√≥n sin aprobaci√≥n
- ‚ùå Inyecci√≥n de implementaciones (`*ServiceImpl`) en lugar de interfaces
- ‚ùå Servicios external fuera del paquete `external/`
- ‚ùå Servicios de organizaci√≥n fuera del paquete `organization/`
- ‚ùå Servicios sin `@Service`, `@Slf4j` o interfaz
- ‚ùå Uso de `@Autowired` en lugar de constructor
- ‚ùå Nomenclatura inconsistente (`premiumcalculation` vs `premiumCalculation`)
- ‚ùå Llamadas directas a Feign Clients desde servicios principales
- ‚ùå Estructura inventada de DTOs o campos "TODO"

## üéØ Objetivo + Regla de Oro

**Objetivo**: Crear servicios mantenibles, testables y que cumplan principios SOLID con arquitectura en capas clara.

**REGLA DE ORO**: "PRIMERO verificar existentes (dto/, documents/, models/, service/), LUEGO solicitar URL + CURL + responses, DESPU√âS preguntar si desea exponer API (servicios de procesamiento/organizaci√≥n son internos por defecto), FINALMENTE preguntar sobre controller (nuevo vs reutilizar). Reutilizar sin modificar tipos/nombres. Arquitectura: Controller (solo si aprobado) ‚Üí Service ‚Üí External (en external/) / Organization (en organization/) ‚Üí Feign. SIEMPRE usar MapStruct para mapeo DTO ‚Üî Entidad. Una responsabilidad por servicio. Interfaces siempre."


> **Ver tambi√©n**: 
> - [servicios-02-feign-client.mdc](./servicios-02-feign-client.mdc) - Feign Clients
> - [servicios-03-feign-config.mdc](./servicios-03-feign-config.mdc) - Configuraci√≥n Feign
> - [servicios-04-excepciones.mdc](./servicios-04-excepciones.mdc) - Excepciones
> - [servicios-05-dtos.mdc](./servicios-05-dtos.mdc) - DTOs
> - [servicios-09-organizacion-capacidades.mdc](./servicios-09-organizacion-capacidades.mdc) - Organizaci√≥n por capacidades
