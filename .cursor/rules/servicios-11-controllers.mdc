---
description: Controllers REST - Paths descriptivos y mejores pr√°cticas
globs: ["**/controller/**/*.java"]
alwaysApply: false
---

# üéÆ Controllers REST - Endpoints Autodocumentados

## üìã TL;DR

- ‚úÖ Paths descriptivos que explican la acci√≥n: `/create`, `/find-by-id/{id}`, `/update/{id}`
- ‚úÖ Patr√≥n consistente: `/acci√≥n` o `/acci√≥n/{id}`
- ‚úÖ Validaciones con `@Valid` en request DTOs
- ‚úÖ Responses con modelo `Response<T>` + HttpStatus correcto
- ‚úÖ **Controller SIN l√≥gica**: Solo recibe, delega al servicio y retorna
- ‚ùå NO paths ambiguos (`/{id}` para m√∫ltiples operaciones)
- ‚ùå NO hardcodear status codes (usar `HttpStatus.OK.value()`)
- ‚ùå **NO construir DTOs, Sort, Pageable ni l√≥gica de negocio en controller**

## üö® Reglas Principales

1. **Paths Descriptivos**: Cada endpoint debe tener un path que explique su acci√≥n (`/create`, `/update/{id}`, `/delete/{id}`, `/find-by-id/{id}`)
2. **Patr√≥n Consistente**: Seguir `/acci√≥n/{id}` para operaciones sobre entidad espec√≠fica, `/acci√≥n` para operaciones generales
3. **Validaciones Autom√°ticas**: `@Valid` en `@RequestBody`, validar par√°metros requeridos
4. **Status HTTP Correcto**: `CREATED (201)` para POST, `OK (200)` para GET/PUT/PATCH, usar `HttpStatus` enum
5. **Logs Informativos**: Log en cada endpoint con m√©todo HTTP, path y datos relevantes (NO sensibles)
6. **üî¥ CR√çTICO - Sin L√≥gica en Controller**: Controller SOLO recibe par√°metros, delega al servicio y construye Response. TODA la l√≥gica (construcci√≥n de DTOs, Sort, Pageable, mapeos, validaciones de negocio) va en el servicio

## üìä Referencia R√°pida

### Convenciones de Paths por Operaci√≥n

| Operaci√≥n | Verbo HTTP | Path Recomendado | Ejemplo Completo | Status |
|-----------|------------|------------------|------------------|--------|
| **Crear** | `POST` | `/create` | `POST /api/v1/users/create` | 201 |
| **Buscar por ID** | `GET` | `/find-by-id/{id}` | `GET /api/v1/users/find-by-id/1` | 200 |
| **Listar todos** | `GET` | `/all` | `GET /api/v1/users/all` | 200 |
| **Buscar con filtros** | `GET` | `/search` | `GET /api/v1/users/search?email=test` | 200 |
| **Buscar con paginaci√≥n** | `GET` | `/search/paginated` | `GET /api/v1/users/search/paginated` | 200 |
| **Actualizar** | `PUT` | `/update/{id}` | `PUT /api/v1/users/update/1` | 200 |
| **Eliminar** | `DELETE` | `/delete/{id}` | `DELETE /api/v1/users/delete/1` | 200 |
| **Activar/Desactivar** | `PATCH` | `/activate/{id}` | `PATCH /api/v1/users/activate/1` | 200 |
| **Cambio de estado** | `PATCH` | `/change-estado/{id}` | `PATCH /api/v1/users/change-password/1` | 200 |

### Estructura de Response Est√°ndar

| Campo | Tipo | Descripci√≥n | Ejemplo |
|-------|------|-------------|---------|
| `failure` | `boolean` | Indica si hubo error | `false` |
| `code` | `int` | Status HTTP | `200` |
| `message` | `String` | Mensaje descriptivo | `"Usuario creado exitosamente"` |
| `body` | `T` | Datos de respuesta | `UserResponseDto` |
| `timestamp` | `String` | Timestamp milisegundos | `"1699887600000"` |

### Anotaciones en Controllers

| Anotaci√≥n | Uso | Ejemplo |
|-----------|-----|---------|
| `@RestController` | Marca clase como controller REST | Obligatorio en clase |
| `@RequestMapping` | Path base del controller | `@RequestMapping("/api/v1/users")` |
| `@RequiredArgsConstructor` | Inyecci√≥n por constructor | Lombok |
| `@Slf4j` | Logger autom√°tico | Lombok |
| `@PostMapping("/path")` | Endpoint POST | Operaciones CREATE |
| `@GetMapping("/path")` | Endpoint GET | Operaciones READ |
| `@PutMapping("/path")` | Endpoint PUT | Operaciones UPDATE completo |
| `@PatchMapping("/path")` | Endpoint PATCH | Operaciones UPDATE parcial |
| `@DeleteMapping("/path")` | Endpoint DELETE | Operaciones DELETE |
| `@Valid` | Validar request DTO | `@Valid @RequestBody UserRequestDto` |
| `@PathVariable` | Variable en path | `@PathVariable Integer id` |
| `@RequestParam` | Query parameter | `@RequestParam(required = false) String email` |
| `@RequestBody` | Body del request | `@RequestBody UserRequestDto request` |

## ‚úÖ Ejemplos

### Ejemplo 1: Endpoint CREATE con Path Descriptivo

```java
/**
 * Crea un nuevo usuario.
 *
 * @param request Datos del usuario a crear
 * @return Response con el usuario creado
 */
@PostMapping("/create")
public ResponseEntity<Response<UserResponseDto>> createUser(
        @Valid @RequestBody UserRequestDto request) {

    log.info("POST /api/v1/users/create - Crear usuario: {}", request.getEmail());

    UserResponseDto user = userService.createUser(request);

    Response<UserResponseDto> response = Response.<UserResponseDto>builder()
            .failure(false)
            .code(HttpStatus.CREATED.value())  // ‚úÖ Status 201
            .message("Usuario creado exitosamente")
            .body(user)
            .timestamp(String.valueOf(System.currentTimeMillis()))
            .build();

    return ResponseEntity.status(HttpStatus.CREATED).body(response);
}
```

**Caracter√≠sticas:**
- ‚úÖ Path `/create` expl√≠cito
- ‚úÖ Log con informaci√≥n relevante
- ‚úÖ `@Valid` para validaciones autom√°ticas
- ‚úÖ Status `201 CREATED` correcto
- ‚úÖ JavaDoc completo

### Ejemplo 2: Endpoint GET con Path Descriptivo

```java
/**
 * Obtiene un usuario por su ID.
 *
 * @param id ID del usuario
 * @return Response con el usuario encontrado
 */
@GetMapping("/find-by-id/{id}")
public ResponseEntity<Response<UserResponseDto>> getUserById(@PathVariable Integer id) {

    log.info("GET /api/v1/users/find-by-id/{} - Consultar usuario", id);

    UserResponseDto user = userService.getUserById(id);

    Response<UserResponseDto> response = Response.<UserResponseDto>builder()
            .failure(false)
            .code(HttpStatus.OK.value())  // ‚úÖ Status 200
            .message("Usuario encontrado")
            .body(user)
            .timestamp(String.valueOf(System.currentTimeMillis()))
            .build();

    return ResponseEntity.ok(response);
}
```

**Beneficios:**
- ‚úÖ `/find-by-id/{id}` es autodocumentado
- ‚úÖ No ambig√ºedad con otros GET endpoints
- ‚úÖ Log con ID consultado

### Ejemplo 3: Endpoint PATCH con Path Descriptivo

```java
/**
 * Cambia la contrase√±a de un usuario.
 *
 * @param id ID del usuario
 * @param passwordRequest Request con la nueva contrase√±a
 * @return Response con confirmaci√≥n
 */
@PatchMapping("/change-password/{id}")
public ResponseEntity<Response<UserResponseDto>> changePassword(
        @PathVariable Integer id,
        @RequestBody PasswordChangeRequest passwordRequest) {

    log.info("PATCH /api/v1/users/change-password/{} - Cambiar contrase√±a", id);

    UserResponseDto user = userService.changePassword(id, passwordRequest.getNewPassword());

    Response<UserResponseDto> response = Response.<UserResponseDto>builder()
            .failure(false)
            .code(HttpStatus.OK.value())
            .message("Contrase√±a cambiada exitosamente")
            .body(user)
            .timestamp(String.valueOf(System.currentTimeMillis()))
            .build();

    return ResponseEntity.ok(response);
}
```

**Caracter√≠sticas:**
- ‚úÖ `/change-password/{id}` muy expl√≠cito
- ‚úÖ PATCH para actualizaci√≥n parcial
- ‚úÖ DTO espec√≠fico para la operaci√≥n

### Ejemplo 4: Comparaci√≥n Antes y Despu√©s

#### ‚ùå ANTES - Paths Ambiguos

```java
@PostMapping  // ‚Üê Ambiguo, no dice qu√© hace
public ResponseEntity<Response<UserResponseDto>> createUser(...)

@GetMapping("/{id}")  // ‚Üê Puede confundirse con otros GET
public ResponseEntity<Response<UserResponseDto>> getUserById(...)

@PutMapping("/{id}")  // ‚Üê Puede confundirse con otros PUT
public ResponseEntity<Response<UserResponseDto>> updateUser(...)

@PatchMapping("/{id}/activate")  // ‚Üê ID despu√©s de la acci√≥n
public ResponseEntity<Response<UserResponseDto>> activateUser(...)
```

#### ‚úÖ DESPU√âS - Paths Descriptivos y Consistentes

```java
@PostMapping("/create")  // ‚Üê Expl√≠cito: crea usuario
public ResponseEntity<Response<UserResponseDto>> createUser(...)

@GetMapping("/find-by-id/{id}")  // ‚Üê Expl√≠cito: busca por ID
public ResponseEntity<Response<UserResponseDto>> getUserById(...)

@PutMapping("/update/{id}")  // ‚Üê Expl√≠cito: actualiza usuario
public ResponseEntity<Response<UserResponseDto>> updateUser(...)

@PatchMapping("/activate/{id}")  // ‚Üê Patr√≥n consistente: /acci√≥n/{id}
public ResponseEntity<Response<UserResponseDto>> activateUser(...)
```

**Beneficios:**
- üéØ **Autodocumentados**: Path explica la operaci√≥n
- üéØ **Consistentes**: Patr√≥n `/acci√≥n/{id}` uniforme
- üéØ **Sin ambig√ºedad**: No hay conflictos entre rutas
- üéØ **Mantenibles**: F√°cil agregar endpoints sin colisiones

## üö´ Restricciones

1. **NO** usar paths ambiguos (`@PostMapping`, `@GetMapping("/{id}")` sin contexto)
2. **NO** mezclar patrones (`/{id}/acci√≥n` y `/acci√≥n/{id}` en el mismo controller)
3. **NO** hardcodear status codes (`response.setStatus(200)` ‚Üí usar `HttpStatus.OK`)
4. **NO** omitir `@Valid` en DTOs de entrada
5. **NO** loguear informaci√≥n sensible (contrase√±as, tokens, datos personales sin enmascarar)
6. **NO** retornar tipos primitivos o DTOs directamente (usar `ResponseEntity<Response<T>>`)
7. **NO** usar m√∫ltiples `@RequestMapping` con valores diferentes en la misma clase
8. **NO** omitir JavaDoc en m√©todos p√∫blicos del controller
9. **NO** crear endpoints sin logs informativos
10. **NO** usar `ResponseEntity.ok()` para errores (usar status apropiado)
11. **üî¥ NO construir DTOs en controller** (`ProductFilterDto.builder()...` ‚Üí mover al servicio)
12. **üî¥ NO construir Sort/Pageable en controller** (`Sort.by()`, `PageRequest.of()` ‚Üí mover al servicio)
13. **üî¥ NO realizar mapeos en controller** (transformaciones DTO ‚Üí Entity ‚Üí mover al servicio)
14. **üî¥ NO validaciones de negocio en controller** (solo `@Valid` autom√°tico, validaciones complejas ‚Üí servicio)
15. **üî¥ NO c√°lculos o procesamiento de datos** (toda l√≥gica ‚Üí servicio)

## ‚úÖ Validaci√≥n Autom√°tica

Cursor debe detectar:

**Paths:**
- ‚ùå `@PostMapping` sin path espec√≠fico
- ‚ùå `@GetMapping("/{id}")` sin prefijo descriptivo
- ‚ùå `@PutMapping("/{id}")` sin prefijo descriptivo
- ‚ùå Patrones inconsistentes (`/{id}/acci√≥n` mezclado con `/acci√≥n/{id}`)
- ‚ùå Paths sin guiones donde corresponde (`/findbyid` ‚Üí `/find-by-id`)

**Responses:**
- ‚ùå Hardcoded status codes (`200`, `201` ‚Üí `HttpStatus.OK.value()`)
- ‚ùå Retorno directo de DTOs sin `ResponseEntity<Response<T>>`
- ‚ùå Falta de `failure`, `code`, `message`, `body`, `timestamp` en Response

**Validaciones:**
- ‚ùå `@RequestBody` sin `@Valid` en operaciones CREATE/UPDATE
- ‚ùå Falta de logs en endpoints
- ‚ùå Logs con informaci√≥n sensible

**Documentaci√≥n:**
- ‚ùå M√©todos p√∫blicos sin JavaDoc
- ‚ùå JavaDoc sin descripci√≥n de par√°metros (`@param`)
- ‚ùå JavaDoc sin descripci√≥n de retorno (`@return`)

**üî¥ L√≥gica en Controller (CR√çTICO):**
- ‚ùå `.builder()` en controller (construcci√≥n de DTOs)
- ‚ùå `Sort.by()` o `PageRequest.of()` en controller
- ‚ùå Imports de `PageRequest`, `Sort` en controller (se√±al de l√≥gica de paginaci√≥n)
- ‚ùå Mapeos o transformaciones de datos (`.map()`, conversiones)
- ‚ùå Condicionales de negocio (`if (price > 100)`, `if (user.isActive())`)
- ‚ùå C√°lculos (`total = price * quantity`, `discount = ...`)
- ‚ùå M√∫ltiples l√≠neas de l√≥gica antes de llamar al servicio

### Ejemplo 5: Controller SIN L√≥gica vs CON L√≥gica

#### ‚ùå ANTES - Controller con L√≥gica de Negocio

```java
@GetMapping("/search/paginated")
public ResponseEntity<Response<PagedProductResponseDto>> searchProductsPaginated(
        @RequestParam(required = false) Integer categoryId,
        @RequestParam(required = false) BigDecimal minPrice,
        @RequestParam(required = false) BigDecimal maxPrice,
        @RequestParam(required = false) Boolean active,
        @RequestParam(required = false) String searchTerm,
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "10") int size,
        @RequestParam(defaultValue = "id") String sortBy,
        @RequestParam(defaultValue = "asc") String sortDir) {

    log.info("GET /api/v1/products/search/paginated - Buscar con filtros");

    // ‚ùå MAL: Construcci√≥n de DTO en controller
    ProductFilterDto filter = ProductFilterDto.builder()
            .categoryId(categoryId)
            .minPrice(minPrice)
            .maxPrice(maxPrice)
            .active(active)
            .searchTerm(searchTerm)
            .build();

    // ‚ùå MAL: L√≥gica de paginaci√≥n en controller
    Sort sort = sortDir.equalsIgnoreCase("desc") ?
            Sort.by(sortBy).descending() : Sort.by(sortBy).ascending();
    Pageable pageable = PageRequest.of(page, size, sort);

    Page<ProductResponseDto> productsPage = productService.getProductsByFilterPaginated(filter, pageable);

    // ‚ùå MAL: Transformaci√≥n de datos en controller
    PagedProductResponseDto pagedResponse = PagedProductResponseDto.fromPage(productsPage);

    return ResponseEntity.ok(Response.<PagedProductResponseDto>builder()
            .failure(false)
            .code(HttpStatus.OK.value())
            .message("Productos encontrados")
            .body(pagedResponse)
            .timestamp(String.valueOf(System.currentTimeMillis()))
            .build());
}
```

**Problemas:**
- üî¥ Controller tiene l√≥gica de construcci√≥n de DTOs
- üî¥ Controller maneja l√≥gica de paginaci√≥n (Sort, Pageable)
- üî¥ Controller realiza transformaciones de datos
- üî¥ Dif√≠cil de testear sin mockear muchas dependencias
- üî¥ Viola Single Responsibility Principle

#### ‚úÖ DESPU√âS - Controller Limpio (Solo Delega)

```java
@GetMapping("/search/paginated")
public ResponseEntity<Response<PagedProductResponseDto>> searchProductsPaginated(
        @RequestParam(required = false) Integer categoryId,
        @RequestParam(required = false) BigDecimal minPrice,
        @RequestParam(required = false) BigDecimal maxPrice,
        @RequestParam(required = false) Boolean active,
        @RequestParam(required = false) String searchTerm,
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "10") int size,
        @RequestParam(defaultValue = "id") String sortBy,
        @RequestParam(defaultValue = "asc") String sortDir) {

    log.info("GET /api/v1/products/search/paginated - Buscar con filtros");

    // ‚úÖ BIEN: Solo delega al servicio con par√°metros individuales
    Page<ProductResponseDto> productsPage = productService.searchProductsPaginated(
            categoryId, minPrice, maxPrice, active, searchTerm,
            page, size, sortBy, sortDir);

    PagedProductResponseDto pagedResponse = PagedProductResponseDto.fromPage(productsPage);

    return ResponseEntity.ok(Response.<PagedProductResponseDto>builder()
            .failure(false)
            .code(HttpStatus.OK.value())
            .message("Productos encontrados")
            .body(pagedResponse)
            .timestamp(String.valueOf(System.currentTimeMillis()))
            .build());
}
```

**Servicio (donde va la l√≥gica):**

```java
@Override
@Transactional(readOnly = true)
public Page<ProductResponseDto> searchProductsPaginated(
        Integer categoryId,
        BigDecimal minPrice,
        BigDecimal maxPrice,
        Boolean active,
        String searchTerm,
        int page,
        int size,
        String sortBy,
        String sortDir) {

    // ‚úÖ BIEN: L√≥gica de construcci√≥n de DTOs en servicio
    ProductFilterDto filter = ProductFilterDto.builder()
            .categoryId(categoryId)
            .minPrice(minPrice)
            .maxPrice(maxPrice)
            .active(active)
            .searchTerm(searchTerm)
            .build();

    // ‚úÖ BIEN: L√≥gica de paginaci√≥n en servicio
    Sort sort = sortDir.equalsIgnoreCase("desc") ?
            Sort.by(sortBy).descending() : Sort.by(sortBy).ascending();
    Pageable pageable = PageRequest.of(page, size, sort);

    // Delegar a m√©todo base
    return getProductsByFilterPaginated(filter, pageable);
}
```

**Beneficios:**
- ‚úÖ **Controller limpio**: Solo recibe, delega y retorna
- ‚úÖ **Testeable**: Controller solo mockea servicio (1 dependencia)
- ‚úÖ **Mantenible**: Cambios de l√≥gica no afectan controller
- ‚úÖ **Reutilizable**: Servicio puede usar l√≥gica desde otros lugares
- ‚úÖ **SRP**: Cada capa tiene una responsabilidad clara

**Regla de 3 L√≠neas:**
Un m√©todo de controller deber√≠a tener m√°ximo 3 acciones:
1. Log informativo
2. Llamada al servicio
3. Construcci√≥n de Response y retorno

## üéØ Objetivo + Regla de Oro

**Objetivo**: Crear controllers con endpoints autodocumentados, paths descriptivos y respuestas consistentes que faciliten el mantenimiento y comprensi√≥n de la API. **Controller sin l√≥gica de negocio**.

**REGLA DE ORO**: "Path descriptivo = Acci√≥n expl√≠cita. Patr√≥n: `/acci√≥n/{id}`. Response est√°ndar con `HttpStatus` enum. `@Valid` en inputs. Logs informativos sin datos sensibles. JavaDoc completo. **Controller SOLO recibe ‚Üí delega ‚Üí retorna. TODA l√≥gica en servicio**."

---

## üìã Checklist de Creaci√≥n de Controller

**Estructura:**
- [ ] `@RestController` + `@RequestMapping("/api/v{version}/{recurso}")`
- [ ] `@RequiredArgsConstructor` + `@Slf4j`
- [ ] Inyecci√≥n de servicios por interfaz

**Endpoints:**
- [ ] Paths descriptivos (CREATE: `/create`, READ: `/find-by-id/{id}`, UPDATE: `/update/{id}`)
- [ ] Patr√≥n consistente en todos los endpoints
- [ ] `@Valid` en `@RequestBody` para validaciones
- [ ] JavaDoc completo con `@param` y `@return`

**Responses:**
- [ ] `ResponseEntity<Response<T>>` en todos los m√©todos
- [ ] Status HTTP correcto (`HttpStatus.CREATED` para POST, `HttpStatus.OK` para otros)
- [ ] Campos `failure`, `code`, `message`, `body`, `timestamp` completos

**Logs:**
- [ ] Log informativo en cada endpoint
- [ ] Sin informaci√≥n sensible en logs
- [ ] Formato consistente: `"{M√âTODO} {PATH} - {Descripci√≥n}"`

**üî¥ Sin L√≥gica en Controller:**
- [ ] **NO** construcci√≥n de DTOs (`.builder()`) ‚Üí mover al servicio
- [ ] **NO** construcci√≥n de Sort/Pageable ‚Üí mover al servicio
- [ ] **NO** imports de `PageRequest`, `Sort`, `Specification` ‚Üí se√±al de l√≥gica
- [ ] **NO** mapeos o transformaciones de datos ‚Üí mover al servicio
- [ ] **NO** validaciones de negocio complejas ‚Üí mover al servicio
- [ ] **NO** c√°lculos o procesamiento ‚Üí mover al servicio
- [ ] ‚úÖ M√©todos siguen patr√≥n: Log ‚Üí Delegar al servicio ‚Üí Construir Response

**Validaci√≥n:**
- [ ] Sin errores de linter
- [ ] Paths sin conflictos
- [ ] Tests unitarios con mocks de servicios
- [ ] Controller solo mockea servicio (1 dependencia)

---

> **Ver tambi√©n**: 
> - [servicios-01-creacion-servicios.mdc](./servicios-01-creacion-servicios.mdc) - Arquitectura en capas
> - [servicios-05-dtos.mdc](./servicios-05-dtos.mdc) - Estructura de DTOs
> - [servicios-10-buenas-practicas.mdc](./servicios-10-buenas-practicas.mdc) - Buenas pr√°cticas generales
